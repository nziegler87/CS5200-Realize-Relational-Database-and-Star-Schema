---
title: "Store XML in a Database"
output:
  html_document:
    df_print: paged
---

```{r}
# TODO: keep this handy: https://dtd.nlm.nih.gov/ncbi/pubmed/doc/out/180101/
# TODO: add in NOT NULL and Foreign Key Constraints
# TODO: look at order of table creation
# TODO: add in disable FK constraints at beginning and then add in
# TODO: do we need to do indexes?
# TODO: do we want to use str_to_title() to standardize journal titles?
# TODO: do we really need sqldf?
```

# Load Packages

```{r}
library(DBI)
library(RMySQL)
library(XML)

library(sqldf)
options(sqldf.driver = "SQLite")   ## Setting needed to use sqldf with non sqlite database

library(dplyr)    ## For removing duplicate values in dataframe
library(stringr)  ## For capitalization
```

## Connection Info for AWS - DONE

```{r}
db_user <- "dbadmin"
db_name <- 'SandboxDB'
db_password <- "dos8JINT.kras8jaun"
db_host <- "cs5200-dbs.ctuc7sl6qeau.us-east-2.rds.amazonaws.com"
db_port <- 3306

dbcon <- dbConnect(MySQL(), dbname = db_name, host = db_host, 
                   port = db_port, user = db_user, password = db_password)
```

# ERD

# Create Tables

## AUTHOR

```{sql connection=dbcon}
DROP TABLE IF EXISTS Author;
```

```{sql connection=dbcon}
CREATE TABLE `Author` (
  `aut_id` int,
  `author_last_name` varchar(200),
  `author_fore_name` varchar(200),
  `author_initials` varchar(5),
  `author_affilitation` blob,
  PRIMARY KEY (`aut_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM Author;
```

## ABSTRACT

```{sql connection=dbcon}
DROP TABLE IF EXISTS Abstract;
```

```{sql connection=dbcon}
CREATE TABLE `Abstract` (
  `abstract_id` int,
  `article_id` int,
  `nlm_category` {background, unassigned, methods, results, conclusions},
  `abstract_label` {background, purpose_and_questions, patients_and_methods, results, conclusions},
  `abstract_text` blob,
  PRIMARY KEY (`abstract_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM Abstract;
```

## ARTICLE AUTHOR JUNCTION

```{sql connection=dbcon}
DROP TABLE IF EXISTS Article_Author_Junction;
```

```{sql connection=dbcon}
CREATE TABLE `Article_Author_Junction` (
  `art_aut_id` int,
  `author_id` int,
  `article_id` int,
  PRIMARY KEY (`art_aut_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM Article_Author_Junction;
```

## ARTICLE

```{sql connection=dbcon}
DROP TABLE IF EXISTS Article;
```

```{sql connection=dbcon}
CREATE TABLE `Article` (
  `art_id` int,
  `article_title` varchar(200),
  `journal_issue_id` int,
  `pub_model` {Print, Print-Electronic, Electronic, Electronic-Print, Electronic-eCollection},
  `date_created` DATE,
  `date_completed` DATE,
  `date_revised` DATE,
  `date_published` DATE,
  PRIMARY KEY (`art_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM Article;
```

## HISTORY

```{sql connection=dbcon}
DROP TABLE IF EXISTS History;
```

```{sql connection=dbcon}
CREATE TABLE `Article_History` (
  `hist_id` int,
  `article_id` int,
  `pub_status` {received, accepted, epublish, entrez, pubmed, medline, revised, aheadofprint},
  `year` datetime,
  `month` int,
  `day` int,
  `hour` int,
  `minute` int,
  PRIMARY KEY (`hist_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM History;
```

## JOURNAL_ISSUE

```{sql connection=dbcon}
DROP TABLE IF EXISTS Journal_Issue;
```

```{sql connection=dbcon}
CREATE TABLE `Journal_Issue` (
  `issue_id` int,
  `journal_id` int,
  `volume` int,
  `issue` int,
  `publication_year` int,
  `publication_month` int,
  PRIMARY KEY (`issue_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM Journal_Issue;
```

## JOURNAL

```{sql connection=dbcon}
DROP TABLE IF EXISTS Journal;
```

```{sql connection=dbcon}
CREATE TABLE `Journal` (
  `j_id` int,
  `journal_name` varchar(200),
  `issn` varchar(20),
  `issn_type` {Electronic, Print},
  `iso_abbreviation` varchar(15),
  PRIMARY KEY (`j_id`)
);
```

```{sql connection=dbcon}
SELECT * FROM Journal;
```

# Load Data

## Helper Functions

### Row Exists

A function to determine if a given row exists in a column. Returns the value of the first column of that row (primary key for that row) if all columns except the first one match, otherwise returns 0.
```{r}
rowExists <- function (aRow, aDF){
  # check if that address is already in the data frame
  num_rows <- nrow(aDF)
  num_cols <- ncol(aDF)
  
  if ( num_rows == 0 ){
    # data frame is empty, so can't exist
    return(0)
  }
  
  for ( i in 1:num_rows ){
    
    # check if all columns match for a row
    if ( all(aDF[i,2:ncol(aDF)] == aRow[1,]) ){
      
      # found a match; return it's ID
      return(aDF[i,1])
    }
  }
  
  # none matched
  return(0)
}
```

```{r}
monthYear <- function(month_text){
  standardized_month_text <- toupper(month_text)
  if ( is.na(standardized_month_text) ) return(NA)
  else if ( standardized_month_text == "JAN" ) return(1)
  else if ( standardized_month_text == "FEB" ) return (2)
  else if ( standardized_month_text == "MAR" ) return (3)
  else if ( standardized_month_text == "APR" ) return (4)
  else if ( standardized_month_text == "MAY" ) return (5)
  else if ( standardized_month_text == "JUN" ) return (6)
  else if ( standardized_month_text == "JUL" ) return (7)
  else if ( standardized_month_text == "AUG" ) return (8)
  else if ( standardized_month_text == "SEP" ) return (9)
  else if ( standardized_month_text == "OCT" ) return (10)
  else if ( standardized_month_text == "NOV" ) return (11)
  else if ( standardized_month_text == "DEC" ) return (12)
  stop("Month text not found. Could not convert to number.")
}
```


## Create Data Frames

```{r}
author.df <- data.frame(aut_id <- as.numeric(),
                        author_last_name <- as.character(),
                        author_fore_name <- as.character(),
                        author_initlas <- as.character(),
                        author_affiliation <- as.character(),
                        stringsAsFactors = FALSE)

abstract.df <- data.frame(abstract_id <- as.numeric(),
                          article_id <- as.numeric(),
                          nlm_category <- as.character(),
                          abstract_label <- as.character(),
                          abstract_text <- as.character(),
                          stringsAsFactors = FALSE)

article_author_junction.df <- data.frame(art_aut_id <- as.numeric(),
                                         author_id <- as.numeric(),
                                         article_id <- as.numeric(),
                                         stringsAsFactors = FALSE)

# Had to put in NA for this to get it to load
article.df <- data.frame(art_id <- as.numeric(NA),
                         article_title <- as.character(NA),
                         journal_issue_id <- as.numeric(NA),
                         pub_model <- as.character(NA),
                         date_created <- as.Date(NA),
                         date_completed <- as.Date(NA),
                         date_revised <- as.Date(NA),
                         date_published <- as.Date(NA),
                         stringsAsFactors = FALSE)

history.df <- data.frame(hist_id <- as.numeric(),
                         article_id <- as.numeric(),
                         pub_status <- as.character(),
                         year <- as.numeric(),
                         month <- as.numeric(),
                         day <- as.numeric(),
                         hour <- as.numeric(),
                         minute <- as.numeric(),
                         stringsAsFactors = FALSE)

# TODO: Should we clean the ISSN to remove - so issue_id can be as.numeric?
journal_issue.df <- data.frame(issue_id <- as.character(),
                               journal_id <- as.numeric(),
                               volume <- as.numeric(),
                               issue <- as.numeric(),
                               publication_year <- as.numeric(),
                               publication_month <- as.numeric(),
                               stringsAsFactors = FALSE)

journal.df <- data.frame(j_id <- as.numeric(),
                         journal_name <- as.character(),
                         issn <- as.character(),
                         issn_type <- as.character(),
                         iso_abbreviation <- as.character(),
                         stringsAsFactors = FALSE)
```

## Parse XML Document

```{r}
fn <- "pubmed_sample.xml"

# Reading the XML file and parse into DOM
xmlDOM <- xmlParse(file = fn)

# get the root node of the DOM tree
r <- xmlRoot(xmlDOM)

# get the number of articles in the XML file
numArticles <- xmlSize(r)
```



```{r}
# This gets you the article information
r[[12]]
```

```{r}
article <- r[[1]]
  x <- "./MedlineCitation/Article/AuthorList/Author"
  x <- xpathSApply(article, x)
  length(x[[1]])
  xmlSize(x[[2]])
```

## Parse Article Information
```{r}
for ( i in 1:numArticles ){
  
  # parse first article information
  article <- r[[i]]

  # ------------------- #
  # Journal Information #
  # ------------------- #
  
  # Journal Title
  journalTitleQuery <- "./MedlineCitation/Article/Journal/Title"
  journalTitle <- xpathSApply(article, journalTitleQuery, xmlValue)

  # Journal Abbreviation
  journalAbbreviationQuery <- "./MedlineCitation/Article/Journal/ISOAbbreviation"
  journalAbbreviation <- xpathSApply(article, journalAbbreviationQuery, xmlValue)
  
  # ISSN ID
  journalISSNQuery <- "./MedlineCitation/Article/Journal/ISSN"
  journalISSN <- xpathSApply(article, journalISSNQuery, xmlValue)
  
  # ISSN Type
  journalIssnTypeQuery <- "./MedlineCitation/Article/Journal/ISSN/@IssnType"
  journalIssnType <- xpathSApply(article, journalIssnTypeQuery)

  # Create temporary data frame to store new journal information
  # TODO: Keep str_to_title()?
  a.journal <- data.frame(str_to_title(journalTitle), journalISSN,
                          journalIssnType, journalAbbreviation, 
                          stringsAsFactors = FALSE)
  
  # Check to see if journal already exists in table
  journalID <- rowExists(a.journal, journal.df)
  
  # If journal doesn't exist, add it to the data frame
  if ( journalID == 0 ){
    
    # Set j_id to be the next unused row num in journal.df
    journalID <- nrow(journal.df) + 1
    
    # TODO: TBH, I don't understand why the first line isn't sufficient
    journal.df[journalID,2:ncol(journal.df)] <- a.journal
    journal.df[journalID, 1] <- journalID
  }
  
  # ------------- #
  # Journal Issue #
  # ------------- #

  # Volume
  journalVolumeQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Volume"
  journalVolume <- xpathSApply(article, journalVolumeQuery, xmlValue)
  
  # Issue
  journalIssueQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Issue"
  journalIssue <- xpathSApply(article, journalIssueQuery, xmlValue)

  # Parse out publication data section of XML document
  publicationDataQuery <- "./MedlineCitation/Article/Journal/JournalIssue/PubDate"
  publicationData <- xpathSApply(article, publicationDataQuery)
  
  # Need to parse date differently: can be stored as MedlineDate or Month/Date
  if ( (xmlName(publicationData[[1]][[1]]) == 'MedlineDate') ){
    
    ## if it is saved as MedlineDate, use substring to extract year and month
    journalIssueYearQuery <-"substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate,1, 4)"
    journalIssueYear <- xpathSApply(article, journalIssueYearQuery, xmlValue)
    
    journalIssueMonthQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate, 6, 3)"
    journalIssueMonth <- xpathSApply(article, journalIssueMonthQuery, xmlValue)
    
    # Use function to convert text month to numeric
    journalIssueMonth <- monthYear(journalIssueMonth)
  } 
  
  ## If it is not saved as Medline, parse out Year and Month
  ## TODO: Same as above, month should be converted from string to number
  else{
    journalIssueYear <- NA
    journalIssueMonth <- NA
    
    # Because not every article has a pub month, using a for loop with xmlName to extract the data
    
    for ( j in 1:xmlSize(publicationData[[1]]) ){
      ## If year is found, save year so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Year' ){
        journalIssueYear <- xmlValue(publicationData[[1]][[j]])
      }
      
      ## If month is found, save so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Month' ){
        journalIssueMonth <- xmlValue(publicationData[[1]][[j]])
        
        # Use function to convert text month to numeric
        journalIssueMonth <- monthYear(journalIssueMonth)
      }
    }
  }
  
  # Check to see if journal issue is already saved
  an.issue <- data.frame(journalID, journalVolume, journalIssue,
                         journalIssueYear, journalIssueMonth,
                         stringsAsFactors = FALSE)

  # Check to see if journal already exists in table
  issue_id <- rowExists(an.issue, journal_issue.df)
  
  # If journal doesn't exist, add it to the data frame
  if ( issue_id == 0 ){
    
    # Set j_id to be the next unused row num in journal.df
    issue_id <- nrow(journal_issue.df) + 1
    
    # TODO: TBH, I don't understand why the first line isn't sufficient
    journal_issue.df[issue_id,2:ncol(journal_issue.df)] <- an.issue
    journal_issue.df[issue_id, 1] <- issue_id
  }
  
  # ------- #
  # Authors #
  # ------- #
  authorsQuery <- "./MedlineCitation/Article/AuthorList/Author"
  authorsResultSet <- xpathSApply(article, authorsQuery)

  for ( i in 1:xmlSize(authorsResultSet) ){
    author <- authorsResultSet[[i]]
    last_name <- str_to_title(xmlValue(author[[1]]))
    fore_name <- str_to_title(xmlValue(author[[2]]))
    initials <- toupper(xmlValue(author[[3]]))

    affiliation <- NA
    if ( xmlSize(author) == 4 ){
      affiliation <- tolower(xmlValue(author[[4]]))
    }

  an.author <- data.frame(last_name, fore_name, initials, affiliation,
                          stringsAsFactors = FALSE)

  author_id <- rowExists(an.author, author.df)

  # If journal doesn't exist, add it to the data frame
  if ( author_id == 0 ){

    # Set author_id to be the next unused row num in author.df
    author_id <- nrow(author.df) + 1

    # TODO: TBH, I don't understand why the first line isn't sufficient
    author.df[author_id,2:ncol(author.df)] <- an.author
    author.df[author_id, 1] <- author_id
    }
  }
} 

```


# Test at extracting article and journal information V3

```{r}
test.df <- data.frame(journalVolume = character(),
                      journalIssue = character(),
                      journalIssueYear = character(),
                      journalIssueMonth = character(),
                      journalTitle = character(),
                      journalAbbreviation = character(),
                      articleTitle = character(),
                      stringsAsFactors = F)

for ( i in 1:numArticles ){
  article <- r[[i]]

  # Journal Information
  
  # Volume
  journalVolumeQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Volume"
  journalVolume <- xpathSApply(article, journalVolumeQuery, xmlValue)
  
  # Issue
  journalIssueQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Issue"
  journalIssue <- xpathSApply(article, journalIssueQuery, xmlValue)

  # Extracting Publication Year
  publicationDataQuery <- "./MedlineCitation/Article/Journal/JournalIssue/PubDate"
  publicationData <- xpathSApply(article, publicationDataQuery)
  
  # If date is stored as MedlineDate, parse differently that if it is saved as separate month / date
  if ( (xmlName(publicationData[[1]][[1]]) == 'MedlineDate') ){
    
    ## if it is saved as MedlineDate, use substring to extract year and month
    ## TODO: Need to change month to int
    journalIssueYearQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate,1, 4)"
    journalIssueYear <- xpathSApply(article, journalIssueYearQuery, xmlValue)
    
    journalIssueMonthQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate, 6, 3)"
    journalIssueMonth <- xpathSApply(article, journalIssueMonthQuery, xmlValue)
  } 
  
  ## If it is not saved as Medline, parse out Year and Month
  ## TODO: Same as above, month should be converted from string to number
  else{
    journalIssueYear <- NA
    journalIssueMonth <- NA
    
    # Because not every article has a pub month, using a for loop with xmlName to extract the data
    
    for ( j in 1:xmlSize(publicationData[[1]]) ){
      ## If year is found, save year so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Year' ){
        journalIssueYear <- xmlValue(publicationData[[1]][[j]])
      }
      
      ## If month is found, save so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Month' ){
        journalIssueMonth <- xmlValue(publicationData[[1]][[j]])
      }
    }
  }
  
  # Journal Title
  journalTitleQuery <- "./MedlineCitation/Article/Journal/Title"
  journalTitle <- xpathSApply(article, journalTitleQuery, xmlValue)
  journalTitle
  
  # Journal Abbreviation
  journalAbbreviationQuery <- "./MedlineCitation/Article/Journal/ISOAbbreviation"
  journalAbbreviation <- xpathSApply(article, journalAbbreviationQuery, xmlValue)
  journalAbbreviation
  
  # Article Title
  articleTitleQuery <- "./MedlineCitation/Article/ArticleTitle"
  articleTitle <- xpathSApply(article, articleTitleQuery, xmlValue)
  articleTitle
  
  test.df[i,] <- c(journalVolume,
                   journalIssue,
                   journalIssueYear,
                   journalIssueMonth,
                   journalTitle,
                   journalAbbreviation,
                   articleTitle)
}
test.df
```

## Pre-Load the Dataframe for Authors

```{r}
## Create temporary dataframe to hold all authors, before duplicates removed
authors.df.temp  <- data.frame(author_last_name = character(),
                               author_fore_name = character(),
                               author_initials = character(),
                               # author_affiliation = character(),
                               stringsAsFactors = F)

## Create a final dataframe to hold authors, after uplicates are removed
authors.df <- data.frame(aid = integer(),
                         author_last_name = character(),
                         author_fore_name = character(),
                         author_initials = character(),
                         # author_affiliation = character(),
                         stringsAsFactors = F)

## Use xpath to extract list of all authors
xpathEx <- "//Author"
authors <- xpathSApply(xmlDOM, xpathEx)

## Iterate through nodes and add all found authors to temp dataframe
## Note conversion to all lower case, which helps in removing duplicates later
for ( i in 1:length(authors)){
  an.author <- authors[[i]]
  last_name <- tolower(xmlValue(an.author[[1]]))
  fore_name <- tolower(xmlValue(an.author[[2]]))
  initials <- toupper(xmlValue(an.author[[3]]))
  new.author <- c(last_name, fore_name, initials)
  authors.df.temp[i,] <- new.author
}

## Use dplyr to remove duplicates
unique.authors <- distinct(authors.df.temp)

## Add finalized author list to dataframe
## Note conversion back to title case
for ( i in 1:nrow(unique.authors)) {
  authors.df[i,] <- c(i, str_to_title(unique.authors[i,1]), 
                      str_to_title(unique.authors[i,2]), unique.authors[i,3])
}

## Ya Lin Chiu and Ya-Lin Chiu as YL
## Paul Christos as P and Paul J Christos as PJ
sqldf("SELECT aid, author_last_name, author_fore_name, author_initials 
       FROM 'authors.df'
       ORDER BY author_last_name")
```

## Dataframe for Journal

```{r}
journal.df <- data.frame(j_id = integer(),
                         journal_title= character(),
                         iso_abbreviation = character(),
                         stringsAsFactors = F)

## Use xpath to extract list of all journals
xpathEx <- "//Journal/Title | //Journal/ISOAbbreviation"
journals <- xpathSApply(xmlDOM, xpathEx, xmlValue)

journalNum <- 1
for ( i in seq(1, (length(journals)), 2) ){
  journal_title <- journals[[i]]
  journal_abv <- journals[[i + 1]]
  new.journal <- c(journalNum, journal_title, journal_abv)
  journal.df[journalNum,] <- new.journal
  journalNum <- journalNum + 1
}

journal.df
```

# Create Star/Snowflake Schema

## (20 pts) Create and populate a star schema with dimension and transaction fact tables. Each row in the fact table will represent one article. Include the image of an updated ERD that contains the fact table and any additional required dimension tables. Populate the star schema in R. When building the schema, look a head to Part 3 as the schema is dependent on the eventual OLAP queries.

## (20 pts) In the same schema as the previous step, create and populate a summary fact table that represents number of articles per time period (quarter, year) by author and by journal. Include the image of an updated ERD that contains the fact table. Populate the fact table in R. When building the schema, look a head to Part 3 as the schema is dependent on the eventual OLAP queries.

# Explore and Mine Data

## (20 pts) Write queries using your data warehouse to explore whether the publications show a seasonal pattern. Look beyond the pattern of number of publications per season. Adjust your fact tables as needed to support your new queries. If you need to update the fact table, document your changes and your reasons why the changes are needed.

# Text XPath queries
```{r}
  query <- "//MedlineCitation/Article/Journal/JournalIssue/@CitedMedium"
  x <- xpathSApply(article, query)
  unique(x)
```


```{r}
dbDisconnect(dbcon)
```
