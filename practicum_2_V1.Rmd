---
title: "Store XML in a Database"
output:
  html_document:
    df_Print: paged
---

```{r}
# Most Important TODO
-------------------------------------------------
# TODO: Check this out...super helpful: https://dtd.nlm.nih.gov/ncbi/pubmed/doc/out/180101/

# TODO: bringing in affiliation is causing many duplicates in the author table...do we clean (make all small caps or all big caps) or delete? Could try something like this: https://astrostatistics.psu.edu/su07/R/library/base/html/agrep.html I'm leaning toward deleting...easier. Check out the author.df and the person with the last name Memtsoudis for an example **

# TODO: I'm stuck on published_date for an article. I'm thinking that we possibly remove published_date from the article table. Instead, because each article is linked to a particular journal issue, that is the published date? There is an ArticleDate element, but that is only for articles that were published electronically...some are missing that info. Also, turns out that DateCreated, DateCompleted, and DateRevised are all connected to the citation (not the article), so I vote we take that out of the article table. **
  # - Hmm do electronic articles have a journal date associated with them?
  # - I agree with removing the DateCreated, DateCompleted and DateRevised - removed!

# Less Important TODO
  -----------------------------------------
# TODO: do we need to do indexes?
# TODO: do we want to use str_to_title() to standardize journal titles?
# TODO: we may not use sqldf / could be removed 
# TODO: the parsing chunk for each article is very long...should probably make some functions
  
  
# Done TODO
-----------------------------
# TODO: add in NOT NULL, move PRIMARY KEY in line with the attribute, and Foreign Key ConstraINTs
# TODO: look at order of table creation **
  # TODO: Update heading information
  # TODO: add in disable FK constraINTs at beginning and then add in


```

# Load Packages

```{r}
library(DBI)
library(RMySQL)
library(XML)

library(sqldf)
options(sqldf.driver = "SQLite")   ## Setting needed to use sqldf with non sqlite database

library(dplyr)    ## For removing duplicate values in dataframe
library(stringr)  ## For capitalization
```

## Connection Info for AWS - DONE

```{r}
db_user <- "dbadmin"
db_name <- 'SandboxDB'
db_password <- "dos8JINT.kras8jaun"
db_host <- "cs5200-dbs.ctuc7sl6qeau.us-east-2.rds.amazonaws.com"
db_port <- 3306

dbcon <- dbConnect(MySQL(), dbname = db_name, host = db_host, 
                   port = db_port, user = db_user, password = db_password)
```

```{r}
# View tables in the database
dbListTables(dbcon)
```

```{sql connection=mydb}
-- Turns off foreign key check
SET FOREIGN_KEY_CHECKS = 0;
```

# ERD

![](PracticumERD.png "Practicum ERD") <https://lucid.app/lucidchart/5a835436-ec1a-461a-94d4-bd4d46ece96f/edit?viewport_loc=-1125%2C-339%2C8042%2C3233%2CqB62~LJfXzY6&invitationId=inv_2685f3e2-beaf-4ddd-808d-a2ccd6c89094>

# Create Tables

## AUTHOR

```{sql connection=dbcon}
DROP TABLE IF EXISTS Author;
```

```{sql connection=dbcon}
CREATE TABLE Author (
  aut_id INT PRIMARY KEY autoincrement,
  author_last_name VARCHAR(255) NOT NULL,
  author_fore_name VARCHAR(255) NOT NULL,
  author_initials VARCHAR(255),
  author_affilitation TEXT -- TODO: changed to TEXT
);
```

```{sql connection=dbcon}
SELECT * FROM Author;
```

## ARTICLE

```{sql connection=dbcon}
DROP TABLE IF EXISTS Article;
```

```{sql connection=dbcon}
CREATE TABLE Article (
  art_id` INT PRIMARY KEY autoincrement,
  article_title VARCHAR(255) NOT NULL,
  journal_issue_id INT NOT NULL,
  pub_model ENUM('Print', 'Print-Electronic', 'Electronic', 'Electronic-Print', 'Electronic-eCollection') NOT NULL,
  date_published DATE NOT NULL -- TODO: Should any of these not be NOT NULL?
);
```

```{sql connection=dbcon}
SELECT * FROM Article;
```

## ABSTRACT

```{sql connection=dbcon}
DROP TABLE IF EXISTS Abstract;
```

```{sql connection=dbcon}
CREATE TABLE Abstract (
  abstract_id INT PRIMARY KEY autoincrement,
  article_id INT NOT NULL,
  nlm_category ENUM('background', 'unassigned', 'methods', 'results', 'conclusions') NOT NULL,
  abstract_label ENUM('background', 'purpose_and_questions', 'patients_and_methods', 'results', 'conclusions') NOT NULL,
  abstract_text TEXT, -- TODO: changed to TEXT
  
  CONSTRAINT article_id_fk FOREIGN KEY (article_id) REFERENCES Article(art_id)
);
```

```{sql connection=dbcon}
SELECT * FROM Abstract;
```

## ARTICLE AUTHOR JUNCTION

```{sql connection=dbcon}
DROP TABLE IF EXISTS Article_Author_Junction;
```

```{sql connection=dbcon}
CREATE TABLE Article_Author_Junction (
  art_aut_id INT PRIMARY KEY autoincrement,
  author_id INT NOT NULL,
  article_id INT NOT NULL,
  
  CONSTRAINT author_id_fk FOREIGN KEY (author_id) REFERENCES Author(aut_id),
  CONSTRAINT article_id_fk FOREIGN KEY (article_id) REFERENCES Article(art_id)
);
```

```{sql connection=dbcon}
SELECT * FROM Article_Author_Junction;
```

## HISTORY

```{sql connection=dbcon}
DROP TABLE IF EXISTS History;
```

```{sql connection=dbcon}
CREATE TABLE History (
  hist_id INT PRIMARY KEY autoincrement,
  article_id INT NOT NULL,
  pub_status ENUM('received', 'accepted', 'epublish', 'entrez', 'pubmed', 'medline', 'revised', 'aheadofprint') NOT NULL,
  year DATE NOT NULL,
  month INT NOT NULL,
  day INT NOT NULL,
  hour INT NOT NULL,
  minute INT NOT NULL,
  
  CONSTRAINT article_id_fk FOREIGN KEY (article_id) REFERENCES Article(art_id)
);
```

```{sql connection=dbcon}
SELECT * FROM History;
```

## JOURNAL

```{sql connection=dbcon}
DROP TABLE IF EXISTS Journal;
```

```{sql connection=dbcon}
CREATE TABLE Journal (
  j_id INT PRIMARY KEY autoincrement,
  journal_name VARCHAR(255) NOT NULL,
  issn VARCHAR(255) NOT NULL,
  issn_type ENUM('Electronic', 'Print') NOT NULL,
  iso_abbreviation VARCHAR(255) NOT NULL
  );
```

```{sql connection=dbcon}
SELECT * FROM Journal;
```

## JOURNAL_ISSUE

```{sql connection=dbcon}
DROP TABLE IF EXISTS Journal_Issue;
```

```{sql connection=dbcon}
CREATE TABLE Journal_Issue (
  issue_id INT PRIMARY KEY autoincrement,
  journal_id INT NOT NULL,
  volume INT NOT NULL,
  issue INT NOT NULL,
  publication_year INT NOT NULL,
  publication_month INT NOT NULL,
  
  CONSTRAINT journal_id_fk FOREIGN KEY (journal_id) REFERENCES Journal(j_id)
);
```

```{sql connection=dbcon}
SELECT * FROM Journal_Issue;
```

# Helper Functions

## Row Exists

A function to determine if a given row exists in a column. Returns the value of the first column of that row (primary key for that row) if all columns except the first one match, otherwise returns 0.

```{r}
# TODO: Why wouldn't we just combine this with the function below?

rowExists <- function (aRow, aDF){
  # check if that address is already in the data frame
  num_rows <- nrow(aDF)
  num_cols <- ncol(aDF)
  
  if ( num_rows == 0 ){
    # data frame is empty, so can't exist
    return(0)
  }
  
  for ( i in 1:num_rows ){
    
    # check if all columns match for a row
    if ( all(aDF[i,2:ncol(aDF)] == aRow[1,]) ){
      
      # found a match; return it's ID
      return(aDF[i,1])
    }
  }
  
  # none matched
  return(0)
}
```

## Return PK

A function that return ths PK of a tuple from a data frame. This should only be used when the value to be found is in the dataframe, otherwise it will throw an error.

```{r}
returnPK <- function (aRow, aDF){
  # check if that address is already in the data frame
  num_rows <- nrow(aDF)
  num_cols <- ncol(aDF)
  
  if ( num_rows == 0 ){
    # data frame is empty, so can't exist
    stop("Data frame in which value should be stored is empty.")
  }
  
  for ( i in 1:num_rows ){
    
    # check if all columns match for a row
    if ( all(aDF[i,2:ncol(aDF)] == aRow[1,]) ){
      
      # found a match; return it's ID
      return(aDF[i,1])
    }
  }
  
  # none matched
  stop("Value could not be found in data frame.")
}
```

## monthYear

A function that converts a three character string, "MAR", to the correct month number. Returns NA if value passed in is NA. Throws an error if the entered VARCHAR(255) is not valid.

```{r}
monthYear <- function(month_VARCHAR(255)){
  standardized_month_VARCHAR(255) <- toupper(month_VARCHAR(255))
  if ( is.na(standardized_month_VARCHAR(255)) ) return(NA)
  else if ( standardized_month_VARCHAR(255) == "JAN" ) return(1)
  else if ( standardized_month_VARCHAR(255) == "FEB" ) return (2)
  else if ( standardized_month_VARCHAR(255) == "MAR" ) return (3)
  else if ( standardized_month_VARCHAR(255) == "APR" ) return (4)
  else if ( standardized_month_VARCHAR(255) == "MAY" ) return (5)
  else if ( standardized_month_VARCHAR(255) == "JUN" ) return (6)
  else if ( standardized_month_VARCHAR(255) == "JUL" ) return (7)
  else if ( standardized_month_VARCHAR(255) == "AUG" ) return (8)
  else if ( standardized_month_VARCHAR(255) == "SEP" ) return (9)
  else if ( standardized_month_VARCHAR(255) == "OCT" ) return (10)
  else if ( standardized_month_VARCHAR(255) == "NOV" ) return (11)
  else if ( standardized_month_VARCHAR(255) == "DEC" ) return (12)
  stop("Month VARCHAR(255) not found. Could not convert to number.")
}
```

## Create Data Frames

```{r}
author.df <- data.frame(aut_id <- as.numeric(),
                        author_last_name <- as.character(),
                        author_fore_name <- as.character(),
                        author_initlas <- as.character(),
                        author_affiliation <- as.character(),
                        stringsAsFactors = FALSE)

abstract.df <- data.frame(abstract_id <- as.numeric(),
                          article_id <- as.numeric(),
                          nlm_category <- as.character(),
                          abstract_label <- as.character(),
                          abstract_VARCHAR(255) <- as.character(),
                          stringsAsFactors = FALSE)

article_author_junction.df <- data.frame(art_aut_id <- as.numeric(),
                                         author_id <- as.numeric(),
                                         article_id <- as.numeric(),
                                         stringsAsFactors = FALSE)

# Had to put in NA for this to get it to load...hopefully it works!
article.df <- data.frame(art_id <- as.numeric(NA),
                         article_title <- as.character(NA),
                         journal_issue_id <- as.numeric(NA),
                         pub_model <- as.character(NA),
                         date_created <- as.Date(NA),
                         date_completed <- as.Date(NA),
                         date_revised <- as.Date(NA),
                         date_published <- as.Date(NA),
                         stringsAsFactors = FALSE)

history.df <- data.frame(hist_id <- as.numeric(),
                         article_id <- as.numeric(),
                         pub_status <- as.character(),
                         year <- as.numeric(),
                         month <- as.numeric(),
                         day <- as.numeric(),
                         hour <- as.numeric(),
                         minute <- as.numeric(),
                         stringsAsFactors = FALSE)

journal_issue.df <- data.frame(issue_id <- as.character(),
                               journal_id <- as.numeric(),
                               volume <- as.numeric(),
                               issue <- as.numeric(),
                               publication_year <- as.numeric(),
                               publication_month <- as.numeric(),
                               stringsAsFactors = FALSE)

journal.df <- data.frame(j_id <- as.numeric(),
                         journal_name <- as.character(),
                         issn <- as.character(),
                         issn_type <- as.character(),
                         iso_abbreviation <- as.character(),
                         stringsAsFactors = FALSE)
```

# Load Data

## Parse XML Document

```{r}
fn <- "pubmed_sample.xml"

# Reading XML file and parse into DOM
xmlDOM <- xmlParse(file = fn) 

# gGt root node 
r <- xmlRoot(xmlDOM) 

# Get number of articles in XML file
numArticles <- xmlSize(r) 
```

## Parse Article Information

```{r}
# Looping through all of the articles
for ( i in 1:numArticles ){
  
  # parse first article
  article <- r[[i]]

  # ------------------- #
  # Journal Information #
  # ------------------- #
  
  # Journal Title
  journalTitleQuery <- "./MedlineCitation/Article/Journal/Title"
  journalTitle <- xpathSApply(article, journalTitleQuery, xmlValue)

  # Journal Abbreviation
  journalAbbreviationQuery <- "./MedlineCitation/Article/Journal/ISOAbbreviation"
  journalAbbreviation <- xpathSApply(article, journalAbbreviationQuery, xmlValue)
  
  # ISSN ID
  journalISSNQuery <- "./MedlineCitation/Article/Journal/ISSN"
  journalISSN <- xpathSApply(article, journalISSNQuery, xmlValue)
  
  # ISSN Type
  journalIssnTypeQuery <- "./MedlineCitation/Article/Journal/ISSN/@IssnType"
  journalIssnType <- xpathSApply(article, journalIssnTypeQuery)

  # Create temporary data frame to store new journal information
  a.journal <- data.frame(str_to_title(journalTitle), journalISSN,
                          journalIssnType, journalAbbreviation, 
                          stringsAsFactors = FALSE)
  
  # Check to see if journal already exists in journal.df
  journalID <- rowExists(a.journal, journal.df)
  
  # If journal doesn't exist, add it to the data frame
  if ( journalID == 0 ){
    
    # Set journalID to be the next unused row num in journal.df
    journalID <- nrow(journal.df) + 1
    
    # TODO: TBH, I don't understand why the first line isn't sufficient
    journal.df[journalID,2:ncol(journal.df)] <- a.journal
    journal.df[journalID, 1] <- journalID
  }
  
  # ------------- #
  # Journal Issue #
  # ------------- #

  # Volume
  journalVolumeQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Volume"
  journalVolume <- xpathSApply(article, journalVolumeQuery, xmlValue)
  
  # Issue
  journalIssueQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Issue"
  journalIssue <- xpathSApply(article, journalIssueQuery, xmlValue)

  # Parse out publication data section of XML document
  publicationDataQuery <- "./MedlineCitation/Article/Journal/JournalIssue/PubDate"
  publicationData <- xpathSApply(article, publicationDataQuery)
  
  # Need to parse date differently: can be stored as MedlineDate or Month/Date
  if ( (xmlName(publicationData[[1]][[1]]) == 'MedlineDate') ) {
    
    ## if it is saved as MedlineDate, use substring to extract year and month
    journalIssueYearQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate,1, 4)"
    journalIssueYear <- xpathSApply(article, journalIssueYearQuery, xmlValue)
    
    journalIssueMonthQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate, 6, 3)"
    journalIssueMonth <- xpathSApply(article, journalIssueMonthQuery, xmlValue)
    
    # Use function to convert VARCHAR(255) month to numeric
    journalIssueMonth <- monthYear(journalIssueMonth)
  } 
  
  ## If it is not saved as Medline, parse out Year and Month
  else{
    journalIssueYear <- NA
    journalIssueMonth <- NA
    
    # Because not every article has a pub month, using a for loop with xmlName to extract the data
    
    for ( j in 1:xmlSize(publicationData[[1]]) ){
      
      ## If year is found, save year so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Year' ){
        journalIssueYear <- xmlValue(publicationData[[1]][[j]])
      }
      
      ## If month is found, save so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Month' ){
        journalIssueMonth <- xmlValue(publicationData[[1]][[j]])
        
        # Use function to convert VARCHAR(255) month to numeric
        journalIssueMonth <- monthYear(journalIssueMonth)
      }
    }
  }
  
  # Check to see if journal issue is already saved
  an.issue <- data.frame(journalID, journalVolume, journalIssue,
                         journalIssueYear, journalIssueMonth,
                         stringsAsFactors = FALSE)

  issue_id <- rowExists(an.issue, journal_issue.df)
  
  # If journal issue doesn't exist, add it to the data frame
  if ( issue_id == 0 ){
    
    # Set issue_id to be the next unused row num in journal_issue.df
    issue_id <- nrow(journal_issue.df) + 1
    
    # TODO: TBH, I don't understand why the first line isn't sufficient
    journal_issue.df[issue_id,2:ncol(journal_issue.df)] <- an.issue
    journal_issue.df[issue_id, 1] <- issue_id
  }
  
  # -------- #
  # Articles #
  # -------- #
  
  # Article Title
  articleTitleQuery <- "./MedlineCitation/Article/ArticleTitle"
  articleTitle <- xpathSApply(article, articleTitleQuery, xmlValue)
  
  pubModelQuery <- "./MedlineCitation/Article/@PubModel"
  pubModel <- xpathSApply(article, pubModelQuery)
  
  # TODO: Continue here

  # ------- #
  # Authors #
  # ------- #
  authorsQuery <- "./MedlineCitation/Article/AuthorList/Author"
  authorsResultSet <- xpathSApply(article, authorsQuery)

  # Loop through the AuthorsSet, extracting info and adding to authors table
  for ( i in 1:xmlSize(authorsResultSet) ){
    
    author <- authorsResultSet[[i]]
    last_name <- str_to_title(xmlValue(author[[1]]))
    fore_name <- str_to_title(xmlValue(author[[2]]))
    initials <- toupper(xmlValue(author[[3]]))

    # TODO: Instead of setting affiliation to NA, I set it to UNKNOWN. Okay? < YES
    affiliation <- "UNKNOWN"
    
    # Because not every author has an affiliation, check for a fourth
    # element before extracting the info
    if ( xmlSize(author) == 4 ){
      affiliation <- tolower(xmlValue(author[[4]]))
    }

    an.author <- data.frame(last_name, fore_name, initials, affiliation,
                          stringsAsFactors = FALSE)

    author_id <- rowExists(an.author, author.df)

    # If author doesn't exist, add it to the data frame
    if ( author_id == 0 ){

      # Set author_id to be the next unused row num in author.df
      author_id <- nrow(author.df) + 1

      # TODO: TBH, I don't understand why the first line isn't sufficient
      author.df[author_id,2:ncol(author.df)] <- an.author
      author.df[author_id, 1] <- author_id
    }
    
    # TODO: Once the article.df is populated, add in a step here to populate the article_author junction table
  }
} 

```

# Upload Data

## Prepare Data: Author

```{r}
dbWriteTable(dbcon, "Author", AuthorTable, row.names = FALSE, append = TRUE)
```

## Prepare Data: Article

```{r}
dbWriteTable(dbcon, "Article", ArticleTable, row.names = FALSE, append = TRUE)
```

## Prepare Data: Abstract

```{r}
dbWriteTable(dbcon, "Abstract", AbstractTable, row.names = FALSE, append = TRUE)
```

## Prepare Data: Article Author Junction

```{r}
dbWriteTable(dbcon, "Article_Author_Junction", Article_Author_Juncion_Table, row.names = FALSE, append = TRUE)
```

## Prepare Data: History

```{r}
dbWriteTable(dbcon, "History", HistoryTable, row.names = FALSE, append = TRUE)
```

## Prepare Data: Journal

```{r}
dbWriteTable(dbcon, "Journal", JournalTable, row.names = FALSE, append = TRUE)
```

## Prepare Data: Journal_Issue

```{r}
dbWriteTable(dbcon, "Journal_Issue", Journal_Issue_Table, row.names = FALSE, append = TRUE)
```

```{sql connection=dbcon}
SET FOREIGN_KEY_CHECKS = 1;
```

# Create Star/Snowflake Schema

## (20 pts) Create and populate a star schema with dimension and transaction fact tables. Each row in the fact table will represent one article. Include the image of an updated ERD that contains the fact table and any additional required dimension tables. Populate the star schema in R. When building the schema, look a head to Part 3 as the schema is dependent on the eventual OLAP queries.

## (20 pts) In the same schema as the previous step, create and populate a summary fact table that represents number of articles per time period (quarter, year) by author and by journal. Include the image of an updated ERD that contains the fact table. Populate the fact table in R. When building the schema, look a head to Part 3 as the schema is dependent on the eventual OLAP queries.

# Explore and Mine Data

## (20 pts) Write queries using your data warehouse to explore whether the publications show a seasonal pattern. Look beyond the pattern of number of publications per season. Adjust your fact tables as needed to support your new queries. If you need to update the fact table, document your changes and your reasons why the changes are needed.

```{r}
dbDisconnect(dbcon)
```

# Everything below this line is simply for testing / experimentation

```{r}
# This gets you the article information
r[[12]]
```

```{r}
article <- r[[1]]
  x <- "./MedlineCitation/Article/ArticleDate"
  x <- xpathSApply(article, x)
  x
```

# Test at extracting article and journal information V3

```{r}
test.df <- data.frame(journalVolume = character(),
                      journalIssue = character(),
                      journalIssueYear = character(),
                      journalIssueMonth = character(),
                      journalTitle = character(),
                      journalAbbreviation = character(),
                      articleTitle = character(),
                      stringsAsFactors = F)

for ( i in 1:numArticles ){
  article <- r[[i]]

  # Journal Information
  
  # Volume
  journalVolumeQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Volume"
  journalVolume <- xpathSApply(article, journalVolumeQuery, xmlValue)
  
  # Issue
  journalIssueQuery <- "./MedlineCitation/Article/Journal/JournalIssue/Issue"
  journalIssue <- xpathSApply(article, journalIssueQuery, xmlValue)

  # Extracting Publication Year
  publicationDataQuery <- "./MedlineCitation/Article/Journal/JournalIssue/PubDate"
  publicationData <- xpathSApply(article, publicationDataQuery)
  
  # If date is stored as MedlineDate, parse differently that if it is saved as separate month / date
  if ( (xmlName(publicationData[[1]][[1]]) == 'MedlineDate') ){
    
    ## if it is saved as MedlineDate, use substring to extract year and month
    ## TODO: Need to change month to INT
    journalIssueYearQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate,1, 4)"
    journalIssueYear <- xpathSApply(article, journalIssueYearQuery, xmlValue)
    
    journalIssueMonthQuery <- "substring(./MedlineCitation/Article/Journal/JournalIssue/PubDate/MedlineDate, 6, 3)"
    journalIssueMonth <- xpathSApply(article, journalIssueMonthQuery, xmlValue)
  } 
  
  ## If it is not saved as Medline, parse out Year and Month
  ## TODO: Same as above, month should be converted from string to number
  else{
    journalIssueYear <- NA
    journalIssueMonth <- NA
    
    # Because not every article has a pub month, using a for loop with xmlName to extract the data
    
    for ( j in 1:xmlSize(publicationData[[1]]) ){
      ## If year is found, save year so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Year' ){
        journalIssueYear <- xmlValue(publicationData[[1]][[j]])
      }
      
      ## If month is found, save so it isn't NA
      if ( xmlName(publicationData[[1]][[j]]) == 'Month' ){
        journalIssueMonth <- xmlValue(publicationData[[1]][[j]])
      }
    }
  }
  
  # Journal Title
  journalTitleQuery <- "./MedlineCitation/Article/Journal/Title"
  journalTitle <- xpathSApply(article, journalTitleQuery, xmlValue)
  journalTitle
  
  # Journal Abbreviation
  journalAbbreviationQuery <- "./MedlineCitation/Article/Journal/ISOAbbreviation"
  journalAbbreviation <- xpathSApply(article, journalAbbreviationQuery, xmlValue)
  journalAbbreviation
  
  # Article Title
  articleTitleQuery <- "./MedlineCitation/Article/ArticleTitle"
  articleTitle <- xpathSApply(article, articleTitleQuery, xmlValue)
  articleTitle
  
  test.df[i,] <- c(journalVolume,
                   journalIssue,
                   journalIssueYear,
                   journalIssueMonth,
                   journalTitle,
                   journalAbbreviation,
                   articleTitle)
}
test.df
```

## Pre-Load the Dataframe for Authors

```{r}
## Create temporary dataframe to hold all authors, before duplicates removed
authors.df.temp  <- data.frame(author_last_name = character(),
                               author_fore_name = character(),
                               author_initials = character(),
                               # author_affiliation = character(),
                               stringsAsFactors = F)

## Create a final dataframe to hold authors, after uplicates are removed
authors.df <- data.frame(aid = INTeger(),
                         author_last_name = character(),
                         author_fore_name = character(),
                         author_initials = character(),
                         # author_affiliation = character(),
                         stringsAsFactors = F)

## Use xpath to extract list of all authors
xpathEx <- "//Author"
authors <- xpathSApply(xmlDOM, xpathEx)

## Iterate through nodes and add all found authors to temp dataframe
## Note conversion to all lower case, which helps in removing duplicates later
for ( i in 1:length(authors)){
  an.author <- authors[[i]]
  last_name <- tolower(xmlValue(an.author[[1]]))
  fore_name <- tolower(xmlValue(an.author[[2]]))
  initials <- toupper(xmlValue(an.author[[3]]))
  new.author <- c(last_name, fore_name, initials)
  authors.df.temp[i,] <- new.author
}

## Use dplyr to remove duplicates
unique.authors <- distinct(authors.df.temp)

## Add finalized author list to dataframe
## Note conversion back to title case
for ( i in 1:nrow(unique.authors)) {
  authors.df[i,] <- c(i, str_to_title(unique.authors[i,1]), 
                      str_to_title(unique.authors[i,2]), unique.authors[i,3])
}

## Ya Lin Chiu and Ya-Lin Chiu as YL
## Paul Christos as P and Paul J Christos as PJ
sqldf("SELECT aid, author_last_name, author_fore_name, author_initials 
       FROM 'authors.df'
       ORDER BY author_last_name")
```

## Dataframe for Journal

```{r}
journal.df <- data.frame(j_id = INTeger(),
                         journal_title= character(),
                         iso_abbreviation = character(),
                         stringsAsFactors = F)

## Use xpath to extract list of all journals
xpathEx <- "//Journal/Title | //Journal/ISOAbbreviation"
journals <- xpathSApply(xmlDOM, xpathEx, xmlValue)

journalNum <- 1
for ( i in seq(1, (length(journals)), 2) ){
  journal_title <- journals[[i]]
  journal_abv <- journals[[i + 1]]
  new.journal <- c(journalNum, journal_title, journal_abv)
  journal.df[journalNum,] <- new.journal
  journalNum <- journalNum + 1
}

journal.df
```

# VARCHAR(255) XPath queries

```{r}
  query <- "//ArticleDate"
  x <- xpathSApply(article, query)
  unique(x)
```
